package chat

import (
	"encoding/json"
	"fmt"
	"greentrade-eu/internal/db"
	"greentrade-eu/lib/errors"
	"time"

	"github.com/gofiber/fiber/v2"
)

type Message struct {
	ID             string    `json:"id"`
	ConversationID string    `json:"conversation_id"`
	SenderID       string    `json:"sender_id"` // Or int, depending on your user ID type
	Content        string    `json:"content"`
	CreatedAt      time.Time `json:"created_at"`
}

func GetMessagesByConversationID(c *fiber.Ctx) error {
	client := db.NewSupabaseClient()

	if client == nil {
		return errors.InternalServerError("Database connection failed. Please check SUPABASE_URL and SUPABASE_ANON.")
	}

	conversationID := c.Params("conversation_id")
	if conversationID == "" {
		return errors.BadRequest("Conversation ID is required")
	}

	query := fmt.Sprintf("conversation_id=eq.%s", conversationID)
	data, err := client.Query("messages", query)

	if err != nil {
		return errors.InternalServerError("Failed to retrieve messages: " + err.Error())
	}

	var messages []Message

	err = json.Unmarshal(data, &messages)
	if err != nil {
		return errors.InternalServerError("Failed to parse messages: " + err.Error())
	}

	return errors.SuccessResponse(c, messages)
}

func PostMessage(c *fiber.Ctx) error {
	var payload struct {
		ConversationID string `json:"conversation_id"`
		SenderID       string `json:"sender_id"`
		Content        string `json:"content"`
	}

	if err := c.BodyParser(&payload); err != nil {
		return errors.BadRequest("Failed to parse JSON payload: " + err.Error())
	}

	// Validate payload
	if payload.ConversationID == "" || payload.SenderID == "" || payload.Content == "" {
		return errors.BadRequest("Missing required fields: conversation_id, sender_id, content")
	}

	client := db.NewSupabaseClient()
	if client == nil {
		return errors.InternalServerError("Database connection failed.")
	}

	// Prepare the message data for insertion
	// Note: ID is usually generated by the database, CreatedAt should be set server-side
	newMessage := map[string]interface{}{
		"conversation_id": payload.ConversationID,
		"sender_id":       payload.SenderID,
		"content":         payload.Content,
		// "created_at" is typically handled by the database default value (e.g., NOW())
	}

	// Marshal the map into JSON bytes
	jsonData, err := json.Marshal(newMessage)
	if err != nil {
		return errors.InternalServerError("Failed to marshal message data: " + err.Error())
	}

	insertedData, err := client.PostRaw("messages", jsonData)
	if err != nil {
		return errors.InternalServerError("Failed to post message: " + err.Error())
	}

	// Optionally parse the inserted data back into a Message struct if needed for the response
	var createdMessages []Message
	if err := json.Unmarshal(insertedData, &createdMessages); err != nil || len(createdMessages) == 0 {
		// Log the error, but maybe still return success as the insert *did* happen
		fmt.Println("Warning: Failed to parse inserted message data:", err)
		// Fallback or simplified success response
		return errors.SuccessResponse(c, fiber.Map{"status": "Message posted successfully"})
	}

	// Return the newly created message
	return errors.SuccessResponse(c, createdMessages[0])
}
